C51 COMPILER V9.55   MAIN                                                                  11/08/2020 22:17:13 PAGE 1   


C51 COMPILER V9.55, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN .\Objects\main.obj
COMPILER INVOKED BY: F:\Keil_v5\C51\BIN\C51.EXE main.c OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND PRINT(.\Listings\main
                    -.lst) OBJECT(.\Objects\main.obj)

line level    source

   1          #include <STC15F2K60S2.H>
   2          #include "iic.h"
   3          #include "onewire.h"
   4          #include <string.h>
   5          #include <stdio.h>
   6          
   7          #define u8 unsigned char
   8          #define u16 unsigned int
   9          
  10          #define get() (P3 & 0X3C) | 0XC3
  11          
  12          sbit TX = P1^0;
  13          sbit RX = P1^1;
  14          
  15          u8 code TAB[] = {0xc0,0xf9,0xa4,0xb0,0x99,0x92,0x82,0xf8,0x80,0x90,0XBF,0XFF,0xc6,0XC7,0XC8,0X8C};
  16          // C:12,L:13,U:14,P:15
  17          u8 disbuf[] = {0,1,2,3,4,5,6,7,8};
  18          
  19          u8 smg_cnt = 0;
  20          u8 key_buf = 0;
  21          
  22          u8 buffer[20];
  23          u8 rx_cnt = 0;
  24          u8 rx_tt = 0;
  25          bit rx_flag = 0;
  26          
  27          u16 down_tt = 0;
  28          u16 down_tt2 = 0;
  29          
  30          u16 change_cnt = 0;
  31          
  32          
  33          u16 temperature = 0;
  34          u16 temperature_tt = 0;
  35          bit temperature_flag = 0;
  36          
  37          bit downlong = 0;
  38          bit downlong1 = 0;
  39          
  40          
  41          bit downlong2 = 0;
  42          bit downlong3 = 0;
  43          
  44          u8 mode = 0;
  45          u16 distance;
  46          
  47          u8 wave_tt = 0;
  48          u8 wave_flag = 0;
  49          
  50          u16 argc_temperature = 3000;
  51          u16 argc_distance = 35;
  52          u16 argc_temperature_temp = 3000;
  53          u16 argc_distance_temp = 35;
  54          bit argc_flag = 0;
C51 COMPILER V9.55   MAIN                                                                  11/08/2020 22:17:13 PAGE 2   

  55          
  56          bit dac_enable = 1;
  57          bit send_enable = 0;
  58          
  59          void set_port(u8 p2,u8 p0)
  60          {
  61   1              P0 = p0;
  62   1              P2 &= 0X1F;
  63   1              P2 |= p2;
  64   1              P0 = p0;
  65   1              P2 &= 0X1F;
  66   1      }
  67          
  68          void allinit(void)
  69          {
  70   1              set_port(0x80,0xff);
  71   1              set_port(0xa0,0x00);
  72   1              set_port(0xc0,0xff);
  73   1              set_port(0xe0,0xff);
  74   1      }
  75          
  76          void Delay5ms()         //@12.000MHz
  77          {
  78   1              unsigned char i, j;
  79   1      
  80   1              i = 59;
  81   1              j = 90;
  82   1              do
  83   1              {
  84   2                      while (--j);
  85   2              } while (--i);
  86   1      }
  87          
  88          void display(void)
  89          {
  90   1              // C:12,L:13,U:14,P:15
  91   1              // 0:温度显示, 1:距离显示，2:变更次数显示，3:参数显示
  92   1              if(mode == 0)   // 温度显示
  93   1              {
  94   2                      disbuf[1] = 12;
  95   2                      disbuf[2] = 11;
  96   2                      disbuf[3] = 11;
  97   2                      disbuf[4] = 11;
  98   2                      disbuf[5] = temperature / 1000;
  99   2                      disbuf[6] = temperature / 100 % 10;
 100   2                      disbuf[7] = temperature / 10 % 10;
 101   2                      disbuf[8] = temperature % 10;
 102   2              }
 103   1              else if(mode == 1)      // 距离显示
 104   1              {
 105   2                      disbuf[1] = 13;
 106   2                      disbuf[2] = 11;
 107   2                      disbuf[3] = 11;
 108   2                      disbuf[4] = 11;
 109   2                      disbuf[5] = 11;
 110   2                      disbuf[6] = 11;
 111   2                      disbuf[7] = distance / 10 % 10;
 112   2                      disbuf[8] = distance % 10;
 113   2              }
 114   1              else if(mode == 2)      // 变更次数显示
 115   1              {
 116   2                      disbuf[1] = 14;
C51 COMPILER V9.55   MAIN                                                                  11/08/2020 22:17:13 PAGE 3   

 117   2                      disbuf[2] = 11;
 118   2                      disbuf[3] = 11;
 119   2                      if(change_cnt / 10000)
 120   2                      {
 121   3                              disbuf[4] = change_cnt / 10000;
 122   3                              disbuf[5] = change_cnt / 1000 % 10;
 123   3                              disbuf[6] = change_cnt / 100 % 10;
 124   3                              disbuf[7] = change_cnt / 10 % 10;
 125   3                              disbuf[8] = change_cnt % 10;
 126   3                      }
 127   2                      else if(change_cnt / 1000 % 10)
 128   2                      {
 129   3                              disbuf[4] = 11;
 130   3                              disbuf[5] = change_cnt / 1000 % 10;
 131   3                              disbuf[6] = change_cnt / 100 % 10;
 132   3                              disbuf[7] = change_cnt / 10 % 10;
 133   3                              disbuf[8] = change_cnt % 10;
 134   3                      }
 135   2                      else if(change_cnt / 100 % 10)
 136   2                      {
 137   3                              disbuf[4] = 11;
 138   3                              disbuf[5] = 11;
 139   3                              disbuf[6] = change_cnt / 100 % 10;
 140   3                              disbuf[7] = change_cnt / 10 % 10;
 141   3                              disbuf[8] = change_cnt % 10;
 142   3                      }
 143   2                      else if(change_cnt / 10 % 10)
 144   2                      {
 145   3                              disbuf[4] = 11;
 146   3                              disbuf[5] = 11;
 147   3                              disbuf[6] = 11;
 148   3                              disbuf[7] = change_cnt / 10 % 10;
 149   3                              disbuf[8] = change_cnt % 10;
 150   3                      }
 151   2                      else
 152   2                      {
 153   3                              disbuf[4] = 11;
 154   3                              disbuf[5] = 11;
 155   3                              disbuf[6] = 11;
 156   3                              disbuf[7] = 11;
 157   3                              disbuf[8] = change_cnt;
 158   3                      }
 159   2              }
 160   1              else if(mode == 3)      // 参数设置
 161   1              {
 162   2                      disbuf[1] = 15;
 163   2                      disbuf[2] = 11;
 164   2                      disbuf[3] = 11;
 165   2                      if(!argc_flag)
 166   2                              disbuf[4] = 1;
 167   2                      else 
 168   2                              disbuf[4] = 2;
 169   2                      disbuf[5] = 11;
 170   2                      disbuf[6] = 11;
 171   2                      if(!argc_flag)
 172   2                      {
 173   3                              disbuf[7] = argc_temperature_temp / 1000 % 10;
 174   3                              disbuf[8] = argc_temperature_temp / 100 % 10;
 175   3                      }
 176   2                      else 
 177   2                      {
 178   3                              disbuf[7] = argc_distance_temp / 10 % 10;
C51 COMPILER V9.55   MAIN                                                                  11/08/2020 22:17:13 PAGE 4   

 179   3                              disbuf[8] = argc_distance_temp % 10;
 180   3                      }
 181   2              }
 182   1      }
 183          
 184          void wave_rec(void)
 185          {
 186   1              u8 num = 10;
 187   1              TX = 0;
 188   1              TL0 = 0xF4;             //设置定时初值
 189   1              TH0 = 0xFF;             //设置定时初值
 190   1              TR0 = 1;                //定时器0打开
 191   1              while(num--)
 192   1              {
 193   2                      while(!TF0);
 194   2                      TF0 = 0;
 195   2                      TX ^= 1;
 196   2              }
 197   1              TR0 = 0;                //定时器0关闭
 198   1              TL0 = 0;                //设置定时初值
 199   1              TH0 = 0;                //设置定时初值
 200   1              TR0 = 1;                //定时器0打开
 201   1              while(RX && !TF0);
 202   1              TR0 = 0;
 203   1              if(TF0)
 204   1              {
 205   2                      TF0 = 0;
 206   2                      distance = 99;
 207   2              }
 208   1              else
 209   1              {
 210   2                      distance = ((TH0 << 8) | TL0) * 0.017;
 211   2                      if(distance > 99) distance = 99;
 212   2              }
 213   1      }
 214          
 215          /*----------------------------
 216          发送串口数据
 217          ----------------------------*/
 218          void SendData(u8 dat)
 219          {
 220   1          SBUF = dat;                 //写数据到UART数据寄存器
 221   1              while(!TI);
 222   1              TI = 0;
 223   1      }
 224          /*----------------------------
 225          发送字符串
 226          ----------------------------*/
 227          void SendString(char *s)
 228          {
 229   1          while (*s)                  //检测字符串结束标志
 230   1          {
 231   2              SendData(*s++);         //发送当前字符
 232   2          }
 233   1      }
 234          
 235          void KBD(void)
 236          {
 237   1              u8 key_temp;
 238   1              P35 = 1; P34 = 1; P32 = 0; P33 = 0;
 239   1              key_temp = get();
 240   1              P35 = 0; P34 = 0; P32 = 1; P33 = 1;
C51 COMPILER V9.55   MAIN                                                                  11/08/2020 22:17:13 PAGE 5   

 241   1              key_temp |= get();
 242   1              if(key_temp != 0xff && key_buf == 0)
 243   1              {
 244   2                      Delay5ms();
 245   2                      P35 = 1; P34 = 1; P32 = 0; P33 = 0;
 246   2                      key_temp = get();
 247   2                      P35 = 0; P34 = 0; P32 = 1; P33 = 1;
 248   2                      key_temp |= get();
 249   2                      if(key_temp != 0xff && key_buf == 0)
 250   2                      {
 251   3                              key_buf = key_temp;
 252   3                      }
 253   2              }
 254   1              else if(key_temp == 0xff && key_buf)
 255   1              {
 256   2                      Delay5ms();
 257   2                      P35 = 1; P34 = 1; P32 = 0; P33 = 0;
 258   2                      key_temp = get();
 259   2                      P35 = 0; P34 = 0; P32 = 1; P33 = 1;
 260   2                      key_temp |= get();
 261   2                      if(key_temp == 0xff && key_buf)
 262   2                      {
 263   3                              // 0:温度显示, 1:距离显示，2:变更次数显示，3:参数显示
 264   3                              switch(key_buf)
 265   3                              {
 266   4                                      case 0xdb:      // s13
 267   4                                              if(!downlong1) // 短按键：界面
 268   4                                              {
 269   5                                                      if(mode != 3)
 270   5                                                      {
 271   6                                                              mode = 3;
 272   6                                                              argc_temperature_temp = argc_temperature;
 273   6                                                              argc_distance_temp = argc_distance;
 274   6                                                              argc_flag = 0;
 275   6                                                      }       
 276   5                                                      else
 277   5                                                      {
 278   6                                                              mode = 0;
 279   6                                                              if(argc_temperature != argc_temperature_temp || argc_distance != argc_distance_temp)
 280   6                                                              {
 281   7                                                                      argc_temperature = argc_temperature_temp;
 282   7                                                                      argc_distance = argc_distance_temp;
 283   7                                                                      change_cnt++;
 284   7                                                                      write_eeprom(0x00,change_cnt / 256);
 285   7                                                                      Delay5ms();
 286   7                                                                      write_eeprom(0x01,change_cnt % 256);
 287   7                                                                      Delay5ms();
 288   7                                                              }
 289   6                                                      }
 290   5                                              }
 291   4                                              down_tt = 0;
 292   4                                              downlong1 = 0;
 293   4                                      break;
 294   4                                      case 0xd7:      // s12
 295   4                                              if(!downlong3) // 短按键：切换
 296   4                                              {
 297   5                                                      if(mode == 3)
 298   5                                                      {
 299   6                                                              argc_flag = !argc_flag;
 300   6                                                      }
 301   5                                                      else if(mode != 3)
 302   5                                                      {
C51 COMPILER V9.55   MAIN                                                                  11/08/2020 22:17:13 PAGE 6   

 303   6                                                              mode = (mode + 1) % 3;
 304   6                                                      }
 305   5                                              }
 306   4                                              down_tt2 = 0;
 307   4                                              downlong3 = 0;
 308   4                                      break;
 309   4                                                             
 310   4                                      case 0xeb:      // s17:加
 311   4                                              if(mode == 3 && argc_flag == 0)
 312   4                                              {
 313   5                                                      if(argc_temperature_temp + 200 < 9900)
 314   5                                                              argc_temperature_temp += 200;
 315   5                                              }
 316   4                                              else if(mode == 3 && argc_flag == 1)
 317   4                                              {
 318   5                                                      if(argc_distance_temp + 5 < 99)
 319   5                                                              argc_distance_temp += 5;
 320   5                                              }
 321   4                                      break;
 322   4                                      case 0xe7:      // s16:减
 323   4                                              if(mode == 3 && argc_flag == 0)
 324   4                                              {
 325   5                                                      if(argc_temperature_temp > 0)
 326   5                                                              argc_temperature_temp -= 200;
 327   5                                              }
 328   4                                              else if(mode == 3 && argc_flag == 1)
 329   4                                              {
 330   5                                                      if(argc_distance_temp > 0)
 331   5                                                              argc_distance_temp -= 5;
 332   5                                              }
 333   4                                      break;
 334   4                              }
 335   3                              key_buf = 0;
 336   3                      }
 337   2              }
 338   1              if(downlong && key_buf == 0xdb) // s13长按键
 339   1              {
 340   2                      downlong = 0;
 341   2                      downlong1 = 1;
 342   2                      dac_enable = !dac_enable;
 343   2              }
 344   1              if(downlong2 && key_buf == 0xd7) // s12长按键
 345   1              {
 346   2                      downlong2 = 0;
 347   2                      downlong3 = 1;
 348   2                      change_cnt = 0;
 349   2                      write_eeprom(0x00,change_cnt / 256);
 350   2                      Delay5ms();
 351   2                      write_eeprom(0x01,change_cnt % 256);
 352   2                      Delay5ms();
 353   2              }
 354   1      }
 355          
 356          void Timer2Init(void)           //1毫秒@12.000MHz
 357          {
 358   1              AUXR |= 0x04;           //定时器时钟1T模式
 359   1              T2L = 0x20;             //设置定时初值
 360   1              T2H = 0xD1;             //设置定时初值
 361   1              AUXR |= 0x10;           //定时器2开始计时
 362   1      }
 363          
 364          void timer2(void) interrupt 12
C51 COMPILER V9.55   MAIN                                                                  11/08/2020 22:17:13 PAGE 7   

 365          {
 366   1              u8 led_state = 0xff;
 367   1              
 368   1              set_port(0xe0,TAB[11]);
 369   1              // 0:温度显示, 1:距离显示，2:变更次数显示，3:参数显示
 370   1              set_port(0xc0,0x01 << smg_cnt);
 371   1              if(mode == 0 && smg_cnt == 5)
 372   1              {
 373   2                      set_port(0xe0,TAB[disbuf[smg_cnt + 1]] & 0x7f);
 374   2              }
 375   1              else 
 376   1                      set_port(0xe0,TAB[disbuf[smg_cnt + 1]]);
 377   1              
 378   1              if(++smg_cnt >= 8) smg_cnt = 0;
 379   1              
 380   1              if(rx_flag && ++rx_tt >= 50)
 381   1              {
 382   2                      rx_flag = 0;
 383   2                      rx_tt = 0;
 384   2                      buffer[rx_cnt++] = '\0';
 385   2                      rx_cnt = 0;
 386   2                      
 387   2                      if(strcmp(buffer,"ST\r\n") == 0)
 388   2                      {
 389   3                              send_enable = 1;
 390   3                              sprintf(buffer,"$%d,%d.%d\r\n",distance,temperature / 100,temperature % 100);
 391   3                      }
 392   2                      else if(strcmp(buffer,"PARA\r\n") == 0)
 393   2                      {
 394   3                              send_enable = 1;
 395   3                              sprintf(buffer,"$%d,%d\r\n",argc_distance,argc_temperature / 100);
 396   3                      }
 397   2                      else
 398   2                      {
 399   3                              send_enable = 1;
 400   3                              sprintf(buffer,"ERROR\r\n");
 401   3                      }
 402   2              }
 403   1              
 404   1              if(!downlong && !downlong1 && key_buf == 0xdb && ++down_tt >= 1000)
 405   1              {
 406   2                      downlong = 1;
 407   2                      down_tt = 0;
 408   2              }
 409   1              
 410   1              if(!downlong2 && !downlong3 && key_buf == 0xd7 && ++down_tt2 >= 1000)
 411   1              {
 412   2                      downlong2 = 1;
 413   2                      down_tt2 = 0;
 414   2              }
 415   1              
 416   1              if(++temperature_tt >= 400)
 417   1              {
 418   2                      temperature_tt = 0;
 419   2                      temperature_flag = 1;
 420   2              }
 421   1              
 422   1              if(++wave_tt >= 255)
 423   1              {
 424   2                      wave_tt = 0;
 425   2                      wave_flag = 1;
 426   2              }
C51 COMPILER V9.55   MAIN                                                                  11/08/2020 22:17:13 PAGE 8   

 427   1              
 428   1              if(temperature > argc_temperature)
 429   1              {
 430   2                      led_state &= 0xfe;
 431   2              }
 432   1              if(distance < argc_distance)
 433   1              {
 434   2                      led_state &= 0xfd;
 435   2              }
 436   1              if(dac_enable)
 437   1              {
 438   2                      led_state &= 0xfb;
 439   2              }
 440   1              
 441   1              set_port(0x80,led_state);
 442   1      }
 443          
 444          void Timer0Init(void)           //12微秒@12.000MHz
 445          {
 446   1              AUXR &= 0x7F;           //定时器时钟12T模式
 447   1              TMOD &= 0xF0;           //设置定时器模式
 448   1              TL0 = 0xF4;             //设置定时初值
 449   1              TH0 = 0xFF;             //设置定时初值
 450   1              TF0 = 0;                //清除TF0标志
 451   1              TR0 = 0;                //定时器0关闭
 452   1      }
 453          
 454          void UartInit(void)             //4800bps@12.000MHz
 455          {
 456   1              SCON = 0x50;            //8位数据,可变波特率
 457   1              AUXR |= 0x40;           //定时器1时钟为Fosc,即1T
 458   1              AUXR &= 0xFE;           //串口1选择定时器1为波特率发生器
 459   1              TMOD &= 0x0F;           //设定定时器1为16位自动重装方式
 460   1              TL1 = 0x8F;             //设定定时初值
 461   1              TH1 = 0xFD;             //设定定时初值
 462   1              ET1 = 0;                //禁止定时器1中断
 463   1              TR1 = 1;                //启动定时器1
 464   1      }
 465          
 466          void uartint()interrupt 4
 467          {
 468   1              if (RI)
 469   1          {
 470   2                      RI = 0;
 471   2                      rx_flag = 1;
 472   2              buffer[rx_cnt++] = SBUF;
 473   2          }
 474   1      }
 475          
 476          void main(void)
 477          {
 478   1              allinit();
 479   1              Timer2Init();
 480   1              Timer0Init();
 481   1              UartInit();
 482   1              ES = 1;
 483   1              IE2 |= 0X04;
 484   1              EA = 1;
 485   1              if(read_eeprom(0x1f) != 123)
 486   1              {
 487   2                      change_cnt = 0;
 488   2                      write_eeprom(0x1f,123);
C51 COMPILER V9.55   MAIN                                                                  11/08/2020 22:17:13 PAGE 9   

 489   2                      Delay5ms();
 490   2              }
 491   1              else
 492   1              {
 493   2                      change_cnt = read_eeprom(0x00);
 494   2                      Delay5ms();
 495   2                      change_cnt = change_cnt * 256 + read_eeprom(0x01);
 496   2                      Delay5ms();
 497   2              }
 498   1              while(1)
 499   1              {
 500   2                      if(temperature_flag)
 501   2                      {
 502   3                              temperature_flag = 0;
 503   3                              temperature = (u16)(rd_temperature() * 100);
 504   3                      }
 505   2                      KBD();
 506   2                      if(wave_flag)
 507   2                      {
 508   3                              wave_flag = 0;
 509   3                              wave_rec();
 510   3                      }
 511   2                      if(send_enable)
 512   2                      {
 513   3                              send_enable = 0;
 514   3                              SendString(buffer);
 515   3                      }
 516   2                      if(distance <= argc_distance)
 517   2                      {
 518   3                              write_pcf8591(102,dac_enable);                  
 519   3                      }
 520   2                      else 
 521   2                      {
 522   3                              write_pcf8591(204,dac_enable);  
 523   3                      }
 524   2                      display();
 525   2              }
 526   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1871    ----
   CONSTANT SIZE    =     57    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     56       4
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      9    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
