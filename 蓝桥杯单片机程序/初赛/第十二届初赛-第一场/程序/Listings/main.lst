C51 COMPILER V9.60.0.0   MAIN                                                              05/08/2021 16:51:36 PAGE 1   


C51 COMPILER V9.60.0.0, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN .\Objects\main.obj
COMPILER INVOKED BY: F:\Keil_v5\C51\BIN\C51.EXE main.c OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND PRINT(.\Listings\main
                    -.lst) TABS(2) OBJECT(.\Objects\main.obj)

line level    source

   1          #include "STC15F2K60S2.h"
   2          #include "onewire.h"
   3          #include "iic.h"
   4          
   5          #define u8 unsigned char
   6          #define u16 unsigned int
   7            
   8          #define         TEMP_INTERFACE            0
   9          #define         DAC_INTERFACE             1
  10          #define         SETTING_INTERFACE         2
  11            
  12          #define get() (P3 & 0X3F) | ((P4 & 0X10) << 3) | ((P4 & 0X04) << 4)
  13            
  14          u8 code TAB[] = {0xc0,0xf9,0xa4,0xb0,0x99,0x92,0x82,0xf8,0x80,0x90,0xbf,0xff,0xc6,0x8c,0x88};
  15          u8 disbuf[] = {0,1,2,3,4,5,6,7,8};
  16          
  17          u8 smg_cnt = 0;
  18          
  19          u8 key_buf = 0;
  20          
  21          u16 sec_tick = 0;
  22          u8 sec_cnt = 0;
  23          
  24          u8 interface = 0;
  25          
  26          u8 temperature_para = 25;
  27          u8 temperature_para_temp = 25;
  28          
  29          bit mode = 0;
  30          
  31          float volt = 3.25;
  32          
  33          float temperature = 0.0;
  34          
  35          void Delay5ms()   //@12.000MHz
  36          {
  37   1        unsigned char i, j;
  38   1      
  39   1        i = 59;
  40   1        j = 90;
  41   1        do
  42   1        {
  43   2          while (--j);
  44   2        } while (--i);
  45   1      }
  46          
  47          void set_port(u8 p2,u8 p0)
  48          {
  49   1        P2 = (P2 & 0x1F) | p2;  // 使能74HC573，与上0x1F是为了不影响其他的端口
  50   1        P0 = p0;
  51   1        P2 &= 0x1F;             // 将数据锁存
  52   1      }
  53          
  54          void allinit(void)
C51 COMPILER V9.60.0.0   MAIN                                                              05/08/2021 16:51:36 PAGE 2   

  55          {
  56   1        set_port(0x80,0xFF);  // 关闭所有LED
  57   1        set_port(0xA0,0x00);  // 关闭继电器，蜂鸣器等外设
  58   1        set_port(0xC0,0x00);  // 关闭数码管位选
  59   1        set_port(0xE0,0x00);  // 关闭数码管段选
  60   1      }
  61          
  62          void display(void)
  63          {
  64   1        if(interface == TEMP_INTERFACE)
  65   1        {
  66   2          disbuf[1] = 12;
  67   2          disbuf[2] = 11;
  68   2          disbuf[3] = 11;
  69   2          disbuf[4] = 11;
  70   2          disbuf[5] = (u16)(temperature * 100) / 1000;
  71   2          disbuf[6] = (u16)(temperature * 100) / 100 % 10;
  72   2          disbuf[7] = (u16)(temperature * 100) / 10 % 10;
  73   2          disbuf[8] = (u16)(temperature * 100) / 1000 % 10;
  74   2        }
  75   1        else if(interface == SETTING_INTERFACE)
  76   1        {
  77   2          disbuf[1] = 13;
  78   2          disbuf[2] = 11;
  79   2          disbuf[3] = 11;
  80   2          disbuf[4] = 11;
  81   2          disbuf[5] = 11;
  82   2          disbuf[6] = 11;
  83   2          disbuf[7] = temperature_para_temp / 10;
  84   2          disbuf[8] = temperature_para_temp % 10;
  85   2        }
  86   1        else if(interface == DAC_INTERFACE)
  87   1        {
  88   2          disbuf[1] = 14;
  89   2          disbuf[2] = 11;
  90   2          disbuf[3] = 11;
  91   2          disbuf[4] = 11;
  92   2          disbuf[5] = 11;
  93   2          disbuf[6] = (u16)(volt * 100) / 100;
  94   2          disbuf[7] = (u16)(volt * 100) / 10 % 10;
  95   2          disbuf[8] = (u16)(volt * 100) % 10;
  96   2        }
  97   1        
  98   1      }
  99          
 100          void Timer2Init(void)   //1毫秒@12.000MHz
 101          {
 102   1        AUXR |= 0x04;   //定时器时钟1T模式
 103   1        T2L = 0x20;   //设置定时初值
 104   1        T2H = 0xD1;   //设置定时初值
 105   1        AUXR |= 0x10;   //定时器2开始计时
 106   1      }
 107          
 108          void KBD(void)
 109          {
 110   1        u8 key_temp ;
 111   1        P3 = 0X0F; P44 = 0; P42 = 0;
 112   1        key_temp = get();
 113   1        P3 = 0XF0; P44 = 1; P42 = 1;
 114   1        key_temp |= get();
 115   1        
 116   1        if(key_temp != 0xff && !key_buf)
C51 COMPILER V9.60.0.0   MAIN                                                              05/08/2021 16:51:36 PAGE 3   

 117   1        {
 118   2          Delay5ms();
 119   2          P3 = 0X0F; P44 = 0; P42 = 0;
 120   2          key_temp = get();
 121   2          P3 = 0XF0; P44 = 1; P42 = 1;
 122   2          key_temp |= get();
 123   2          if(key_temp != 0xff && !key_buf)
 124   2          { 
 125   3            key_buf = key_temp;
 126   3          }
 127   2        }
 128   1        else if(key_temp == 0xff && key_buf)
 129   1        {
 130   2          Delay5ms();
 131   2          P3 = 0X0F; P44 = 0; P42 = 0;
 132   2          key_temp = get();
 133   2          P3 = 0XF0; P44 = 1; P42 = 1;
 134   2          key_temp |= get();
 135   2          if(key_temp == 0xff && key_buf)
 136   2          { 
 137   3            switch(key_buf) // 这里要特别注意是key_buf，不要粗心写成了key_temp
 138   3            {
 139   4      //        case 0x7e: disbuf[1] = 7; disbuf[2] = 10; disbuf[3] = 10; break;
 140   4      //        case 0x7d: disbuf[1] = 6; disbuf[2] = 10; disbuf[3] = 10; break;
 141   4              case 0x7b:        // s5
 142   4                mode = !mode;
 143   4              
 144   4              break;
 145   4              case 0x77:        // s6
 146   4                switch(interface)
 147   4                {
 148   5                  case TEMP_INTERFACE: 
 149   5                    temperature_para_temp = temperature_para;
 150   5                    interface = SETTING_INTERFACE; 
 151   5                    
 152   5                  break;
 153   5                  case SETTING_INTERFACE:
 154   5                    temperature_para = temperature_para_temp;
 155   5                    interface = DAC_INTERFACE; 
 156   5                  break;
 157   5                  case DAC_INTERFACE: 
 158   5                    interface = TEMP_INTERFACE; 
 159   5                  break;
 160   5                }
 161   4              break;
 162   4              
 163   4      //        case 0xbe: disbuf[1] = 1; disbuf[2] = 1; disbuf[3] = 10; break;
 164   4      //        case 0xbd: disbuf[1] = 1; disbuf[2] = 0; disbuf[3] = 10; break;
 165   4              case 0xbb: 
 166   4                temperature_para_temp++;
 167   4              
 168   4              break;
 169   4              case 0xb7: 
 170   4                temperature_para_temp--;
 171   4              break;
 172   4              
 173   4      //        case 0xde: disbuf[1] = 1; disbuf[2] = 5; disbuf[3] = 10; break;
 174   4      //        case 0xdd: disbuf[1] = 1; disbuf[2] = 4; disbuf[3] = 10; break;
 175   4      //        case 0xdb: disbuf[1] = 1; disbuf[2] = 3; disbuf[3] = 10; break;
 176   4      //        case 0xd7: disbuf[1] = 1; disbuf[2] = 2; disbuf[3] = 10; break;
 177   4      //                               
 178   4      //        case 0xee: disbuf[1] = 1; disbuf[2] = 9; disbuf[3] = 10; break;
C51 COMPILER V9.60.0.0   MAIN                                                              05/08/2021 16:51:36 PAGE 4   

 179   4      //        case 0xed: disbuf[1] = 1; disbuf[2] = 8; disbuf[3] = 10; break;
 180   4      //        case 0xeb: disbuf[1] = 1; disbuf[2] = 7; disbuf[3] = 10; break;
 181   4      //        case 0xe7: disbuf[1] = 1; disbuf[2] = 6; disbuf[3] = 10; break;       
 182   4            }
 183   3            key_buf = 0;
 184   3          }
 185   2        }
 186   1        
 187   1        
 188   1      }
 189          
 190          void smg_proc(void)
 191          {
 192   1        set_port(0xc0, 0x01 << smg_cnt);
 193   1        if((interface == TEMP_INTERFACE && smg_cnt == 5) || (interface == DAC_INTERFACE && smg_cnt == 5))
 194   1          set_port(0xe0, TAB[disbuf[smg_cnt + 1]]  & 0x7F);
 195   1        else
 196   1          set_port(0xe0, TAB[disbuf[smg_cnt + 1]]);
 197   1        if(++smg_cnt >= 8) smg_cnt = 0;
 198   1        
 199   1        if(++sec_tick == 1000)
 200   1        {
 201   2          sec_tick = 0;
 202   2          (sec_cnt != 59)?(sec_cnt++):(sec_cnt = 0);
 203   2        }
 204   1      }
 205          
 206          void dac_proc(void)
 207          {
 208   1        if(mode == 0)
 209   1        {
 210   2          if(temperature < temperature_para)
 211   2            write_pcf8591(0);
 212   2          else
 213   2            write_pcf8591(255);
 214   2        }
 215   1        else
 216   1        {
 217   2          if(temperature < 20)
 218   2            write_pcf8591(0);
 219   2          else if(temperature > 40)
 220   2            write_pcf8591(255);
 221   2          else
 222   2            write_pcf8591((6.0 / 40 * temperature - 2) / 5.0 * 255);
 223   2        }
 224   1      }
 225          
 226          void led_proc(void)
 227          {
 228   1        u8 led_state = 0xff;
 229   1        if(mode == 0)
 230   1          led_state &= 0xFE;
 231   1        if(interface == TEMP_INTERFACE)
 232   1          led_state &= 0xFD;
 233   1        else if(interface == SETTING_INTERFACE)
 234   1          led_state &= 0xFB;
 235   1        else if(interface == DAC_INTERFACE)
 236   1          led_state &= 0xF7;
 237   1        set_port(0x80,led_state);
 238   1      }
 239          
 240          /********************* Timer2中断函数************************/
C51 COMPILER V9.60.0.0   MAIN                                                              05/08/2021 16:51:36 PAGE 5   

 241          void timer2_int (void) interrupt 12
 242          {
 243   1        smg_proc();
 244   1        
 245   1        led_proc();
 246   1      }
 247          
 248          
 249          void main(void)
 250          {
 251   1        allinit();                      // 上电初始化
 252   1        Timer2Init();                   // 定时器2初始化
 253   1        IE2 |= 0x04;                    // 开定时器2中断
 254   1        EA = 1;                         // 开启总中断
 255   1        
 256   1        while(1)
 257   1        {
 258   2          temperature = read_temperature();
 259   2          
 260   2          dac_proc();
 261   2          
 262   2          display();
 263   2          
 264   2          KBD();
 265   2        }
 266   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1020    ----
   CONSTANT SIZE    =     15    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     25    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      1    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
