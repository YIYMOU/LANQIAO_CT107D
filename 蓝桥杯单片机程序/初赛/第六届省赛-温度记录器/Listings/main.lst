C51 COMPILER V9.55   MAIN                                                                  10/14/2020 22:25:07 PAGE 1   


C51 COMPILER V9.55, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN .\Objects\main.obj
COMPILER INVOKED BY: F:\Keil_v5\C51\BIN\C51.EXE main.c OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND PRINT(.\Listings\main
                    -.lst) OBJECT(.\Objects\main.obj)

line level    source

   1          #include <STC15F2K60S2.H>
   2          #include "ds1302.h"
   3          #include "onewire.h"
   4          
   5          #define u8 unsigned char
   6          #define u16 unsigned int
   7          
   8          // 1 1 1 1 1 1 1 1 
   9          #define get() (P3 & 0X3F) | ((P4 & 0X04) << 4) | ((P4 & 0X10) << 3)
  10          
  11          u8 code TAB[] = {0xc0,0xf9,0xa4,0xb0,0x99,0x92,0x82,0xf8,0x80,0x90,0xbf,0xff};
  12          u8 disbuf[] = {0,1,2,3,4,5,6,7,8};
  13          u8 key_buf = 0;
  14          extern u8 TIME[];
  15          u8 temperature[] = {0,0,0,0,0,0,0,0,0,0};
  16          u8 set_time = 1;
  17          u8 set_time_temp = 1;
  18          u8 display_mode = 1;
  19          u16 led_tt = 0;
  20          u8 led_open = 0;
  21          u8 index = 0;
  22          u16 temperature_tt = 0;
  23          u8 sec_cnt = 0;
  24          u8 temp_cnt = 11;
  25          u8 read_flag = 0;
  26          bit seting = 1;
  27          void Delay5ms()         //@12.000MHz
  28          {
  29   1              unsigned char i, j;
  30   1      
  31   1              i = 59;
  32   1              j = 90;
  33   1              do
  34   1              {
  35   2                      while (--j);
  36   2              } while (--i);
  37   1      }
  38          
  39          void set_display_mode(u8 mode)
  40          {
  41   1              if(mode == 1)   //
  42   1              {
  43   2                      disbuf[1] = 11;
  44   2                      disbuf[2] = 11;
  45   2                      disbuf[3] = 11;
  46   2                      disbuf[4] = 11;
  47   2                      disbuf[5] = 11;
  48   2                      disbuf[6] = 10;
  49   2                      disbuf[7] = set_time_temp / 10;
  50   2                      disbuf[8] = set_time_temp % 10;
  51   2              }
  52   1              else if(mode == 2)
  53   1              {
  54   2                      disbuf[1] = TIME[2] / 16;
C51 COMPILER V9.55   MAIN                                                                  10/14/2020 22:25:07 PAGE 2   

  55   2                      disbuf[2] = TIME[2] % 16;
  56   2                      if(TIME[0] % 2)
  57   2                      {
  58   3                              disbuf[3] = 10;
  59   3                              disbuf[6] = 10;
  60   3                      }
  61   2                      else
  62   2                      {
  63   3                              disbuf[3] = 11;
  64   3                              disbuf[6] = 11;
  65   3                      }
  66   2                      disbuf[4] = TIME[1] / 16;
  67   2                      disbuf[5] = TIME[1] % 16;
  68   2                      disbuf[7] = TIME[0] / 16;
  69   2                      disbuf[8] = TIME[0] % 16;       
  70   2              }
  71   1              else if(display_mode == 3)
  72   1              {
  73   2                      disbuf[1] = 10;
  74   2                      disbuf[2] = index / 10;
  75   2                      disbuf[3] = index % 10;
  76   2                      disbuf[4] = 11;
  77   2                      disbuf[5] = 11;
  78   2                      disbuf[6] = 10;
  79   2                      disbuf[7] = temperature[index] / 10;
  80   2                      disbuf[8] = temperature[index] % 10;
  81   2              }
  82   1      }
  83          void set_port(u8 p2,u8 p0)
  84          {
  85   1              P2 &= 0X1F;
  86   1              P2 |= p2;
  87   1              P0 = p0;
  88   1              P2 &= 0X1F;
  89   1      }
  90          
  91          void allinit(void)
  92          {
  93   1              set_port(0x80,0xff);
  94   1              set_port(0xa0,0x00);
  95   1              set_port(0xc0,0xff);
  96   1              set_port(0xe0,0xff);
  97   1      }
  98          
  99          void BTN(void)
 100          {
 101   1              u8 temp = P3 & 0X0F;
 102   1              if(temp != 0x0f && key_buf == 0)
 103   1              {
 104   2                      Delay5ms();
 105   2                      temp = P3 & 0x0f;
 106   2                      if(temp != 0x0f && key_buf == 0)
 107   2                      {
 108   3                              key_buf = temp;
 109   3                      }
 110   2              }
 111   1              else if(temp == 0x0f && key_buf)
 112   1              {
 113   2                      Delay5ms();
 114   2                      temp = P3 & 0x0f;
 115   2                      if(temp == 0x0f && key_buf)
 116   2                      {
C51 COMPILER V9.55   MAIN                                                                  10/14/2020 22:25:07 PAGE 3   

 117   3                              switch(key_buf)
 118   3                              {
 119   4                                      case 0x0e: 
 120   4                                              if(display_mode == 3)
 121   4                                              {
 122   5                                                      seting = 1;
 123   5                                                      display_mode = 1;
 124   5                                              }
 125   4                                      break;
 126   4                                      case 0x0d: 
 127   4                                              if(display_mode == 3)
 128   4                                              {
 129   5                                                      index = (index + 1) %10;        
 130   5                                                      led_open = 0;
 131   5                                              }
 132   4                                      break;
 133   4                                      case 0x0b: 
 134   4                                              if(display_mode == 1)
 135   4                                              {
 136   5                                                      set_time = set_time_temp;
 137   5                                                      set_time_temp = 1;
 138   5                                                      display_mode = 2;
 139   5                                                      temp_cnt = 0;
 140   5                                                      temperature_tt = 0;
 141   5                                                      sec_cnt = 0;
 142   5                                              }
 143   4                                      break;
 144   4                                      case 0x07: 
 145   4                                              if(display_mode == 1)
 146   4                                              {
 147   5                                                      if(set_time_temp == 0)
 148   5                                                      {
 149   6                                                              set_time_temp = 1;
 150   6                                                      }
 151   5                                                      if(set_time_temp == 1)
 152   5                                                      {
 153   6                                                              set_time_temp = 5;
 154   6                                                      }
 155   5                                                      else if(set_time_temp == 5)
 156   5                                                      {
 157   6                                                              set_time_temp = 30;
 158   6                                                      }
 159   5                                                      else if(set_time_temp == 30)
 160   5                                                      {
 161   6                                                              set_time_temp = 60;
 162   6                                                      }
 163   5                                                      else if(set_time_temp == 60)
 164   5                                                      {
 165   6                                                              set_time_temp = 1;
 166   6                                                      }
 167   5                                              }
 168   4                                      break;
 169   4                              }
 170   3                      }
 171   2                      key_buf = 0;
 172   2              }
 173   1      }
 174          
 175          //void KBD(void)
 176          //{
 177          //      u8 key_temp;
 178          //      P3 = 0X0F; P44 = 0; P42 = 0;
C51 COMPILER V9.55   MAIN                                                                  10/14/2020 22:25:07 PAGE 4   

 179          //      key_temp = get();
 180          //      P3 = 0Xf0; P44 = 1; P42 = 1;
 181          //      key_temp |= get();
 182          //      if(key_temp != 0xff && key_buf == 0)
 183          //      {
 184          //              Delay5ms();
 185          //              P3 = 0X0F; P44 = 0; P42 = 0;
 186          //              key_temp = get();
 187          //              P3 = 0Xf0; P44 = 1; P42 = 1;
 188          //              key_temp |= get();
 189          //              if(key_temp != 0xff && key_buf == 0)
 190          //              {
 191          //                      key_buf = key_temp;
 192          //              }
 193          //      }
 194          //      else if(key_temp == 0xff && key_buf)
 195          //      {
 196          //              Delay5ms();
 197          //              P3 = 0X0F; P44 = 0; P42 = 0;
 198          //              key_temp = get();
 199          //              P3 = 0Xf0; P44 = 1; P42 = 1;
 200          //              key_temp |= get();
 201          //              if(key_temp == 0xff && key_buf)
 202          //              {
 203          //                      switch(key_buf)
 204          //                      {
 205          //                              case 0xe7: disbuf[1] = 0; disbuf[2] = 7; disbuf[3] = 10; break;
 206          //                              case 0xeb: disbuf[1] = 0; disbuf[2] = 6; disbuf[3] = 10; break;
 207          //                              case 0xed: disbuf[1] = 0; disbuf[2] = 5; disbuf[3] = 10; break;
 208          //                              case 0xee: disbuf[1] = 0; disbuf[2] = 4; disbuf[3] = 10; break;
 209          //                              case 0xd7: disbuf[1] = 1; disbuf[2] = 1; disbuf[3] = 10; break;
 210          //                              case 0xdb: disbuf[1] = 1; disbuf[2] = 0; disbuf[3] = 10; break;
 211          //                              case 0xdd: disbuf[1] = 0; disbuf[2] = 9; disbuf[3] = 10; break;
 212          //                              case 0xde: disbuf[1] = 0; disbuf[2] = 8; disbuf[3] = 10; break;
 213          //                              case 0xb7: disbuf[1] = 1; disbuf[2] = 5; disbuf[3] = 10; break;
 214          //                              case 0xbb: disbuf[1] = 1; disbuf[2] = 4; disbuf[3] = 10; break;
 215          //                              case 0xbd: disbuf[1] = 1; disbuf[2] = 3; disbuf[3] = 10; break;
 216          //                              case 0xbe: disbuf[1] = 1; disbuf[2] = 2; disbuf[3] = 10; break;
 217          //                              case 0x77: disbuf[1] = 1; disbuf[2] = 9; disbuf[3] = 10; break;
 218          //                              case 0x7b: disbuf[1] = 1; disbuf[2] = 8; disbuf[3] = 10; break;
 219          //                              case 0x7d: disbuf[1] = 1; disbuf[2] = 7; disbuf[3] = 10; break;
 220          //                              case 0x7e: disbuf[1] = 1; disbuf[2] = 6; disbuf[3] = 10; break;
 221          //                      }
 222          //                      
 223          //              }
 224          //              key_buf = 0;
 225          //      }
 226          //}
 227          
 228          void Timer1Init(void)           //100微秒@12.000MHz
 229          {
 230   1              AUXR |= 0x40;           //定时器时钟1T模式
 231   1              TMOD &= 0x0F;           //设置定时器模式
 232   1              TL1 = 0x50;             //设置定时初值
 233   1              TH1 = 0xFB;             //设置定时初值
 234   1              TF1 = 0;                //清除TF1标志
 235   1              TR1 = 1;                //定时器1开始计时
 236   1      }
 237          
 238          
 239          void timer0(void) interrupt 3
 240          {
C51 COMPILER V9.55   MAIN                                                                  10/14/2020 22:25:07 PAGE 5   

 241   1              static u8 smg_tt = 0, smg_cnt = 0;
 242   1              static u8 led_flag = 0;
 243   1              if(++smg_tt == 20)
 244   1              {
 245   2                      smg_tt = 0;
 246   2                      set_port(0xc0, 0x01 << smg_cnt);
 247   2                      set_port(0xe0, TAB[disbuf[smg_cnt + 1]]);
 248   2                      if(++smg_cnt == 8) smg_cnt = 0;
 249   2              }
 250   1              
 251   1              if(++led_tt == 5000)
 252   1              {
 253   2                      
 254   2                      led_tt = 0;
 255   2                      if(led_open == 0)
 256   2                      {
 257   3                              set_port(0x80,0xff);
 258   3                      }
 259   2                      else
 260   2                      {
 261   3                              if(led_flag)
 262   3                              {
 263   4                                      set_port(0x80,0xfe);
 264   4                              }
 265   3                              else 
 266   3                              {
 267   4                                      set_port(0x80,0xff);
 268   4                              }
 269   3                              led_flag = !led_flag;
 270   3                      }
 271   2              }
 272   1              
 273   1              if(temp_cnt != 11 && ++temperature_tt == 10000)
 274   1              {
 275   2                      temperature_tt = 0;
 276   2                      if(temp_cnt == 10)
 277   2                      {
 278   3                              led_open = 1;
 279   3                              display_mode = 3;
 280   3                              index = 0;
 281   3                              temp_cnt = 11;
 282   3                      }
 283   2                      else if(++sec_cnt == set_time)
 284   2                      {
 285   3                              sec_cnt = 0;
 286   3                              read_flag = 1;
 287   3                      }
 288   2              }
 289   1      }
 290          
 291          void main()
 292          {
 293   1              allinit();
 294   1              Timer1Init();
 295   1              EA = 1;
 296   1              ET1 = 1;
 297   1              dis1302_init();
 298   1              while(1)
 299   1              {
 300   2                      dis1302_read();
 301   2      //              disbuf[1] = TIME[2] / 16;
 302   2      //              disbuf[2] = TIME[2] % 16;
C51 COMPILER V9.55   MAIN                                                                  10/14/2020 22:25:07 PAGE 6   

 303   2      //              disbuf[3] = 10;
 304   2      //              disbuf[4] = TIME[1] / 16;
 305   2      //              disbuf[5] = TIME[1] % 16;
 306   2      //              disbuf[6] = 10;
 307   2      //              disbuf[7] = TIME[0] / 16;
 308   2      //              disbuf[8] = TIME[0] % 16;
 309   2      //              temperature = (u8)(rd_temperature());
 310   2                      if(display_mode != 3)
 311   2                      {
 312   3                              index = 10;
 313   3                      }
 314   2                      if(read_flag)
 315   2                      {
 316   3                              temperature[temp_cnt++] = (u8)(rd_temperature());
 317   3                              read_flag = 0;
 318   3                      }
 319   2                      set_display_mode(display_mode);
 320   2                      BTN();
 321   2              }
 322   1              
 323   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    699    ----
   CONSTANT SIZE    =     12    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     35    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      1    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
